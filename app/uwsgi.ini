[uwsgi]
# linux系统下默认用户名
uid=root
# 项目名
project=ghost_sa
logs_dir=/app/logs/ghost/logs
module = wsgi
callable = app
enable-threads = false
socket=/var/tmp/%(project).sock
chmod-socket = 660
py-autoreload = 0
# 服务停止时，自动移除unix socket和pid文件
vacuum = true
lazy-apps = true
system_environments = production
FLASK_ENV = production
# workers = 8
master = true
listen = 65535
socket-timeout=65
# 当一个请求花费的时间超过这个时间，那么这个请求都会被丢弃。
harakiri-timeout=65
# 当一个请求被harakiri杀掉会输出一条日志
harakiri-verbose=true
# uWsgi默认的buffersize为4096，如果请求数据超过这个量会报错。这里设置为32k
buffer-size = 32768
# 如果http请求体的大小超过指定的限制，打开http body缓冲，这里为32k
post-buffering=32768
# 为每个工作进程设置请求数的上限。当处理的请求总数超过这个量，进程回收重启。
max-requests = 0
# 设置平滑的重启（直到处理完接收到的请求）的长等待时间(秒)
reload-mercy=10
# 开启内存使用情况报告
memory-report=true
#设置工作进程使用虚拟内存超过多少MB就回收重启
reload-on-as=1024

# 在worker中接收请求的函数wsgi_req_accept有一个锁：thunder_lock，这个锁用来串行化accept，防止“惊群”现象：参考这里
thunder-lock=true

; 单独开一个线程进行 log 写入工作，这样有更好的性能
threaded-log = true
logger = file:%(logs_dir)/%(project).log
log-truncate = true
req-logger = file:%(logs_dir)/uwsgi_%(project)_reqlog.log
# 不记录请求信息request的日志。只记录错误以及uWSGI内部消息到日志中
disable-logging = true
# 以后台守护进程运行，并将logs日志存于应用日志文件夹。
# daemonize = %(logs_dir)/uwsgi_%(project).log
